<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Background Animation</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            overflow: hidden;
            height: 100vh;
        }
        
        #matrix-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        .container {
            position: relative;
            z-index: 10;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .content {
            text-align: center;
            color: #00ff41;
            font-size: clamp(2rem, 6vw, 4rem);
            font-weight: 700;
            text-shadow: 0 0 20px #00ff41;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { 
                text-shadow: 0 0 20px #00ff41, 0 0 30px #00ff41; 
            }
            to { 
                text-shadow: 0 0 30px #00ff41, 0 0 50px #00ff41, 0 0 70px #00ff41; 
            }
        }
    </style>
</head>
<body>
    <canvas id="matrix-canvas"></canvas>
    
    <div class="container">
        <div class="content">Xoperr Dev</div>
    </div>

    <script>
        const canvas = document.getElementById('matrix-canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Matrix characters - mix of letters, numbers, and symbols
        const matrixChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()_+-=[]{}|;:,.<>?';
        const charArray = matrixChars.split('');
        
        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);
        
        // Array to track falling characters for each column
        const drops = [];
        const speeds = [];
        const trails = []; // Store characters for each trail
        
        // Initialize arrays
        for (let i = 0; i < columns; i++) {
            drops[i] = Math.floor(Math.random() * canvas.height / fontSize);
            speeds[i] = Math.random() * 0.02 + 0.01;
            trails[i] = []; // Initialize trail for this column
            
            // Fill initial trail with random characters
            for (let j = 0; j < 20; j++) {
                trails[i][j] = charArray[Math.floor(Math.random() * charArray.length)];
            }
        }
        
        function drawMatrix() {
            // Create fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Set font
            ctx.font = `${fontSize}px Orbitron`;
            
            for (let i = 0; i < drops.length; i++) {
                const x = i * fontSize;
                
                // Occasionally update characters in the trail (less frequently for more natural look)
                if (Math.random() < 0.03) {
                    const randomPos = Math.floor(Math.random() * trails[i].length);
                    trails[i][randomPos] = charArray[Math.floor(Math.random() * charArray.length)];
                }
                
                // Draw trail of characters for each column
                for (let j = 0; j < 15; j++) {
                    const char = trails[i][j] || charArray[Math.floor(Math.random() * charArray.length)];
                    const y = (drops[i] - j) * fontSize;
                    
                    if (y > -fontSize && y < canvas.height + fontSize) {
                        // Determine color based on position in trail
                        if (j === 0) {
                            ctx.fillStyle = '#ffffff'; // Bright white for the head
                        } else if (j <= 2) {
                            ctx.fillStyle = '#ccffcc'; // Light green for next few
                        } else {
                            // Smooth fade from green to transparent
                            const opacity = Math.max(0.05, 0.9 - (j / 15));
                            ctx.fillStyle = `rgba(0, 255, 65, ${opacity})`;
                        }
                        
                        ctx.fillText(char, x, y);
                    }
                }
                
                // Move drop down
                drops[i] += speeds[i];
                
                // When head moves to new position, shift trail characters
                if (Math.floor(drops[i]) !== Math.floor(drops[i] - speeds[i])) {
                    // Shift trail down and add new character at front
                    trails[i].unshift(charArray[Math.floor(Math.random() * charArray.length)]);
                    if (trails[i].length > 20) {
                        trails[i].pop();
                    }
                }
                
                // Reset drop when it goes off screen
                if (drops[i] * fontSize > canvas.height + fontSize * 15) {
                    drops[i] = -Math.random() * 20; // Start above screen
                    speeds[i] = Math.random() * 0.02 + 0.01;
                }
            }
        }
        
        // Animation loop
        let lastTime = 0;
        const targetFPS = 30; // Limit to 30 FPS for slower tempo
        const frameInterval = 1000 / targetFPS;
        
        function animate(currentTime) {
            if (currentTime - lastTime >= frameInterval) {
                drawMatrix();
                lastTime = currentTime;
            }
            requestAnimationFrame(animate);
        }
        
        animate(0);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            const newColumns = Math.floor(canvas.width / fontSize);
            
            // Adjust arrays for new column count
            while (drops.length < newColumns) {
                drops.push(Math.floor(Math.random() * canvas.height / fontSize));
                speeds.push(Math.random() * 0.02 + 0.01);
                
                // Initialize trail for new column
                const newTrail = [];
                for (let j = 0; j < 20; j++) {
                    newTrail[j] = charArray[Math.floor(Math.random() * charArray.length)];
                }
                trails.push(newTrail);
            }
            
            if (drops.length > newColumns) {
                drops.length = newColumns;
                speeds.length = newColumns;
                trails.length = newColumns;
            }
        });
    </script>
</body>
</html>
